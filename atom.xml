<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>橙子</title>
  <subtitle>大道至简</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.orangezhang.com/"/>
  <updated>2017-06-23T06:30:54.134Z</updated>
  <id>http://www.orangezhang.com/</id>
  
  <author>
    <name>orange</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SolrCloud 集群搭建</title>
    <link href="http://www.orangezhang.com/2017/06/23/solr/"/>
    <id>http://www.orangezhang.com/2017/06/23/solr/</id>
    <published>2017-06-23T06:30:54.092Z</published>
    <updated>2017-06-23T06:30:54.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.1什么是SolrCloud</strong></p>
<pre><code>SolrCloud(solr 云)是Solr提供的分布式搜索方案，当你需要大规模，容错，分布式索引和检索能力时使用 SolrCloud。当一个系统的索引数据量少的时候是不需要使用SolrCloud的，当索引量很大，搜索请求并发很高，这时需要使用SolrCloud来满足这些需求。
</code></pre><p>SolrCloud是基于Solr和Zookeeper的分布式搜索方案，它的主要思想是使用Zookeeper作为集群的配置信息中心。<br>它有几个特色功能：<br>1）集中式的配置信息<br>2）自动容错<br>3）近实时搜索<br>4）查询时自动负载均衡</p>
<p>zookeeper是个什么玩意？<br>顾名思义zookeeper就是动物园管理员，他是用来管hadoop（大象）、Hive(蜜蜂)、pig(小猪)的管理员， Apache Hbase和 Apache Solr 的分布式集群都用到了zookeeper；Zookeeper:是一个分布式的、开源的程序协调服务，是hadoop项目下的一个子项目。</p>
<hr>
<p><strong>1.2    SolrCloud结构</strong></p>
<pre><code>SolrCloud为了降低单机的处理压力，需要由多台服务器共同来完成索引和搜索任务。实现的思路是将索引数据进行Shard（分片）拆分，每个分片由多台的服务器共同完成，当一个索引或搜索请求过来时会分别从不同的Shard的服务器中操作索引。
</code></pre><p>SolrCloud需要Solr基于Zookeeper部署，Zookeeper是一个集群管理软件，由于SolrCloud需要由多台服务器组成，由zookeeper来进行协调管理。</p>
<p>下图是一个SolrCloud应用的例子：</p>
<p><img src="http://i.imgur.com/1QVJdQH.png" alt=""></p>
<p>对上图进行图解，如下：<br><img src="http://i.imgur.com/e8tYbVL.png" alt=""></p>
<hr>
<p><strong>1.2.1    物理结构</strong></p>
<pre><code>三个Solr实例（ 每个实例包括两个Core），组成一个SolrCloud
</code></pre><hr>
<p><strong>1.2.2    逻辑结构</strong></p>
<pre><code>索引集合包括两个Shard（shard1和shard2），shard1和shard2分别由三个Core组成，其中一个Leader两个Replication，Leader是由zookeeper选举产生，zookeeper控制每个shard上三个Core的索引数据一致，解决高可用问题。
</code></pre><hr>
<p><strong>1.2.2.1    collection</strong></p>
<pre><code>Collection在SolrCloud集群中是一个逻辑意义上的完整的索引结构。它常常被划分为一个或多个Shard（分片），它们使用相同的配置信息。
</code></pre><p>比如：针对商品信息搜索可以创建一个collection。</p>
<p> collection=shard1+shard2+….+shardX</p>
<hr>
<p><strong>1.2.2.2    Core</strong><br>Collection在SolrCloud集群中是一个逻辑意义上的完整的索引结构。它常常被划分为一个或多个Shard（分片），它们使用相同的配置信息。</p>
<hr>
<p><strong>1.2.2.3    Master或Slave</strong></p>
<h2 id="Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。"><a href="#Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。" class="headerlink" title="Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。"></a>Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.1什么是SolrCloud&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SolrCloud(solr 云)是Solr提供的分布式搜索方案，当你需要大规模，容错，分布式索引和检索能力时使用 SolrCloud。当一个系统的索引数据量少的时候是不需要使用
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SolrCloud 集群搭建</title>
    <link href="http://www.orangezhang.com/2017/06/23/SVN%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.orangezhang.com/2017/06/23/SVN使用/</id>
    <published>2017-06-23T06:21:23.875Z</published>
    <updated>2017-06-23T06:30:16.386Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.1什么是SolrCloud</strong></p>
<pre><code>SolrCloud(solr 云)是Solr提供的分布式搜索方案，当你需要大规模，容错，分布式索引和检索能力时使用 SolrCloud。当一个系统的索引数据量少的时候是不需要使用SolrCloud的，当索引量很大，搜索请求并发很高，这时需要使用SolrCloud来满足这些需求。
</code></pre><p>SolrCloud是基于Solr和Zookeeper的分布式搜索方案，它的主要思想是使用Zookeeper作为集群的配置信息中心。<br>它有几个特色功能：<br>1）集中式的配置信息<br>2）自动容错<br>3）近实时搜索<br>4）查询时自动负载均衡</p>
<p>zookeeper是个什么玩意？<br>顾名思义zookeeper就是动物园管理员，他是用来管hadoop（大象）、Hive(蜜蜂)、pig(小猪)的管理员， Apache Hbase和 Apache Solr 的分布式集群都用到了zookeeper；Zookeeper:是一个分布式的、开源的程序协调服务，是hadoop项目下的一个子项目。</p>
<hr>
<p><strong>1.2    SolrCloud结构</strong></p>
<pre><code>SolrCloud为了降低单机的处理压力，需要由多台服务器共同来完成索引和搜索任务。实现的思路是将索引数据进行Shard（分片）拆分，每个分片由多台的服务器共同完成，当一个索引或搜索请求过来时会分别从不同的Shard的服务器中操作索引。
</code></pre><p>SolrCloud需要Solr基于Zookeeper部署，Zookeeper是一个集群管理软件，由于SolrCloud需要由多台服务器组成，由zookeeper来进行协调管理。</p>
<p>下图是一个SolrCloud应用的例子：</p>
<p><img src="http://i.imgur.com/1QVJdQH.png" alt=""></p>
<p>对上图进行图解，如下：<br><img src="http://i.imgur.com/e8tYbVL.png" alt=""></p>
<hr>
<p><strong>1.2.1    物理结构</strong></p>
<pre><code>三个Solr实例（ 每个实例包括两个Core），组成一个SolrCloud
</code></pre><hr>
<p><strong>1.2.2    逻辑结构</strong></p>
<pre><code>索引集合包括两个Shard（shard1和shard2），shard1和shard2分别由三个Core组成，其中一个Leader两个Replication，Leader是由zookeeper选举产生，zookeeper控制每个shard上三个Core的索引数据一致，解决高可用问题。
</code></pre><hr>
<p><strong>1.2.2.1    collection</strong></p>
<pre><code>Collection在SolrCloud集群中是一个逻辑意义上的完整的索引结构。它常常被划分为一个或多个Shard（分片），它们使用相同的配置信息。
</code></pre><p>比如：针对商品信息搜索可以创建一个collection。</p>
<p> collection=shard1+shard2+….+shardX</p>
<hr>
<p><strong>1.2.2.2    Core</strong><br>Collection在SolrCloud集群中是一个逻辑意义上的完整的索引结构。它常常被划分为一个或多个Shard（分片），它们使用相同的配置信息。</p>
<hr>
<p><strong>1.2.2.3    Master或Slave</strong></p>
<h2 id="Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。"><a href="#Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。" class="headerlink" title="Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。"></a>Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.1什么是SolrCloud&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SolrCloud(solr 云)是Solr提供的分布式搜索方案，当你需要大规模，容错，分布式索引和检索能力时使用 SolrCloud。当一个系统的索引数据量少的时候是不需要使用
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hibernate框架</title>
    <link href="http://www.orangezhang.com/2017/06/23/Hibernate%20%E5%85%A5%E9%97%A8/"/>
    <id>http://www.orangezhang.com/2017/06/23/Hibernate 入门/</id>
    <published>2017-06-23T06:18:12.940Z</published>
    <updated>2017-06-23T06:18:12.991Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p><strong>今天任务</strong></p>
<pre><code>1. 使用Hibernate框架完成对客户的增删改查的操作
</code></pre><hr>
<p><strong>教学导航</strong></p>
<pre><code>1. 能够说出Hibernate的执行流程
2. 能够独立使用Hibernate框架完成增删改查的操作
</code></pre><hr>
<p><strong>框架和CRM项目的整体介绍</strong></p>
<pre><code>1. 什么是CRM
    * CRM（Customer Relationship Management）客户关系管理，是利用相应的信息技术以及互联网技术来协调企业与顾客间在销售、营销和服务上的交互，向客户提供创新式的个性化的客户交互和服务的过程
    * 其最终目标是将面向客户的各项信息和活动集成起来，组建一个以客户为中心的企业，实现对面向客户的活动的全面管理

2. CRM的模块
    * CRM系统实现了对企业销售、营销、服务等各阶段的客户信息、客户活动进行统一管理。
    * CRM系统功能涵盖企业销售、营销、用户服务等各各业务流程，业务流程中与客户相关活动都会在CRM系统统一管理。
    * 下边列出一些基本的功能模块，包括：
        * 客户信息管理
        * 联系人管理
        * 商机管理
        * 统计分析等
</code></pre><p><img src="./图片/01-CRM模块.bmp" alt=""></p>
<pre><code>3. 模块的具体功能
    * 客户信息管理
        * 对客户信息统一维护，客户是指存量客户或拟营销的客户，通过员工录入形成公司的“客户库”是公司最重要的数据资源。

    * 联系人管理
        * 对客户的联系人信息统一管理，联系人是指客户企业的联系人，即企业的业务人员和客户的哪些人在打交道。

    * 客户拜访管理
        * 业务员要开发客户需要去拜访客户，客户拜访信息记录了业务员与客户沟通交流方面的不足、采取的策略不当、有待改进的地方或值得分享的沟通技巧等方面的信息。

    * 综合查询
        * 客户相关信息查询，包括：客户信息查询、联系人信息查询、商机信息查询等

    * 统计分析
        * 按分类统计客户信息，包括：客户信息来源统计、按行业统计客户、客户发展数量统计等

    * 系统管理
        系统管理属于crm系统基础功能模块，包括：数据字典、账户管理、角色管理、权限管理、操作日志管理等
</code></pre><p><img src="./图片/02-SSH框架.bmp" alt=""></p>
<hr>
<p><strong>Hibernate框架的学习路线</strong></p>
<pre><code>1. 注意：Hibernate框架知识点非常多，比较杂乱，大家要做好笔记记录的工作
2. 学习的路线
    * 第一天：主要是学习框架的入门，自己搭建框架，完成增删改查的操作
    * 第二天：主要学习一级缓存、事务管理和基本的查询
    * 第三天：主要学习一对多和多对多的操作等
    * 第四天：基本查询和查询的优化
</code></pre><p><img src="./图片/03-Hibernate的开发位置.bmp" alt=""></p>
<hr>
<h3 id="案例一：完成客户的CRUD的操作"><a href="#案例一：完成客户的CRUD的操作" class="headerlink" title="案例一：完成客户的CRUD的操作"></a>案例一：完成客户的CRUD的操作</h3><hr>
<p><strong>需求分析</strong></p>
<pre><code>1. CRM系统中客户信息管理模块功能包括
    * 新增客户信息
    * 客户信息查询
    * 修改客户信息
    * 删除客户信息

2. 要实现客户的新增功能
</code></pre><hr>
<h3 id="技术分析之Hibernate框架的概述"><a href="#技术分析之Hibernate框架的概述" class="headerlink" title="技术分析之Hibernate框架的概述"></a>技术分析之Hibernate框架的概述</h3><hr>
<p><strong>Hibernate框架的概述</strong></p>
<pre><code>1. Hibernate框架的概述
    * Hibernate称为
    * Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 
    * Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。
    * Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架

2. 记住：Hibernate是一个持久层的ORM框架！！！
</code></pre><hr>
<p><strong>什么是ORM（对象关系映射）</strong></p>
<pre><code>1. ORM映射：Object Relational Mapping
    * O：面向对象领域的Object（JavaBean对象）
    * R：关系数据库领域的Relational（表的结构）
    * M：映射Mapping（XML的配置文件）

2. 简单一句话：Hibernate使程序员通过操作对象的方式来操作数据库表记录
</code></pre><p><img src="./图片/04-ORM概述.bmp" alt=""></p>
<hr>
<p><strong>Hibernate优点</strong></p>
<pre><code>1. 优点
    * Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码
    * Hibernate是一个基于jdbc的主流持久化框架，是一个优秀的orm实现，它很大程度的简化了dao层编码工作
    * Hibernate的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系
</code></pre><hr>
<h3 id="技术分析之Hibernate框架的快速入门"><a href="#技术分析之Hibernate框架的快速入门" class="headerlink" title="技术分析之Hibernate框架的快速入门"></a>技术分析之Hibernate框架的快速入门</h3><hr>
<p><strong>第一步：下载Hibernate5的运行环境</strong></p>
<pre><code>1. 下载相应的jar包等
    * http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/hibernate-release-5.0.7.Final.zip/download    

2. 解压后对目录结构有一定的了解
</code></pre><hr>
<p><strong>第二步：创建表结构</strong></p>
<pre><code>1. 建表语句如下
    Create database hibernate_day01;
    Use hibernate_day01;
    CREATE TABLE `cst_customer` (
      `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT &apos;客户编号(主键)&apos;,
      `cust_name` varchar(32) NOT NULL COMMENT &apos;客户名称(公司名称)&apos;,
      `cust_user_id` bigint(32) DEFAULT NULL COMMENT &apos;负责人id&apos;,
      `cust_create_id` bigint(32) DEFAULT NULL COMMENT &apos;创建人id&apos;,
      `cust_source` varchar(32) DEFAULT NULL COMMENT &apos;客户信息来源&apos;,
      `cust_industry` varchar(32) DEFAULT NULL COMMENT &apos;客户所属行业&apos;,
      `cust_level` varchar(32) DEFAULT NULL COMMENT &apos;客户级别&apos;,
      `cust_linkman` varchar(64) DEFAULT NULL COMMENT &apos;联系人&apos;,
      `cust_phone` varchar(64) DEFAULT NULL COMMENT &apos;固定电话&apos;,
      `cust_mobile` varchar(16) DEFAULT NULL COMMENT &apos;移动电话&apos;,
      PRIMARY KEY (`cust_id`)
    ) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8;
</code></pre><hr>
<p><strong>第三步：搭建Hibernate的开发环境</strong></p>
<pre><code>1. 创建WEB工程，引入Hibernate开发所需要的jar包
    * MySQL的驱动jar包
    * Hibernate开发需要的jar包（资料/hibernate-release-5.0.7.Final/lib/required/所有jar包）
    * 日志jar包（资料/jar包/log4j/所有jar包）
</code></pre><hr>
<p><strong>第四步：编写JavaBean实体类</strong></p>
<pre><code>1. Customer类的代码如下：
    public class Customer {
        private Long cust_id;
        private String cust_name;
        private Long cust_user_id;
        private Long cust_create_id;
        private String cust_source;
        private String cust_industry;
        private String cust_level;
        private String cust_linkman;
        private String cust_phone;
        private String cust_mobile;
        // 省略get和set方法
    }
</code></pre><hr>
<p><strong>第五步：创建类与表结构的映射</strong></p>
<pre><code>1. 在JavaBean所在的包下创建映射的配置文件
    * 默认的命名规则为：实体类名.hbm.xml
    * 在xml配置文件中引入约束（引入的是hibernate3.0的dtd约束，不要引入4的约束）
        &lt;!DOCTYPE hibernate-mapping PUBLIC 
            &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
            &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;

2. 如果不能上网，编写配置文件是没有提示的，需要自己来配置
    * 先复制http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd --&gt; window --&gt; preferences --&gt; 搜索xml --&gt; 选择xml catalog --&gt; 点击add --&gt; 现在URI --&gt; 粘贴复制的地址 --&gt; 选择location，选择本地的DTD的路径

3. 编写映射的配置文件
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE hibernate-mapping PUBLIC 
        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
        &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;

    &lt;hibernate-mapping&gt;
        &lt;class name=&quot;com.itheima.domain.Customer&quot; table=&quot;cst_customer&quot;&gt;
            &lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot;&gt;
                &lt;generator class=&quot;native&quot;/&gt;
            &lt;/id&gt;
            &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot;/&gt;
            &lt;property name=&quot;cust_user_id&quot; column=&quot;cust_user_id&quot;/&gt;
            &lt;property name=&quot;cust_create_id&quot; column=&quot;cust_create_id&quot;/&gt;
            &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot;/&gt;
            &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&gt;
            &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&gt;
            &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot;/&gt;
            &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&gt;
            &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&gt;
        &lt;/class&gt;
    &lt;/hibernate-mapping&gt;
</code></pre><hr>
<p><strong>第六步：编写Hibernate核心的配置文件</strong></p>
<pre><code>1. 在src目录下，创建名称为hibernate.cfg.xml的配置文件
2. 在XML中引入DTD约束
    &lt;!DOCTYPE hibernate-configuration PUBLIC
        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;

3. 打开：资料/hibernate-release-5.0.7.Final/project/etc/hibernate.properties，可以查看具体的配置信息    
    * 必须配置的4大参数                    
        #hibernate.connection.driver_class com.mysql.jdbc.Driver
        #hibernate.connection.url jdbc:mysql:///test
        #hibernate.connection.username gavin
        #hibernate.connection.password

    * 数据库的方言（必须配置的）
        #hibernate.dialect org.hibernate.dialect.MySQLDialect

    * 可选的配置
        #hibernate.show_sql true
        #hibernate.format_sql true
        #hibernate.hbm2ddl.auto update

    * 引入映射配置文件（一定要注意，要引入映射文件，框架需要加载映射文件）
        * &lt;mapping resource=&quot;com/itheima/domain/Customer.hbm.xml&quot;/&gt;                

4. 具体的配置如下
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE hibernate-configuration PUBLIC
        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;

    &lt;hibernate-configuration&gt;
        &lt;session-factory&gt;
            &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;
            &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt;
            &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt;
            &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt;
            &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;

            &lt;mapping resource=&quot;com/itheima/domain/Customer.hbm.xml&quot;/&gt;
        &lt;/session-factory&gt;
    &lt;/hibernate-configuration&gt;
</code></pre><hr>
<p><strong>第七步：编写Hibernate入门代码</strong>    </p>
<pre><code>1. 具体的代码如下
    /**
     * 测试保存客户
     */
    @Test
    public void testSave(){
        // 先加载配置文件
        Configuration config = new Configuration();
        // 默认加载src目录下的配置文件
        config.configure();
        // 创建SessionFactory对象
        SessionFactory factory = config.buildSessionFactory();
        // 创建session对象
        Session session = factory.openSession();
        // 开启事务
        Transaction tr = session.beginTransaction();
        // 编写保存代码
        Customer c = new Customer();
        // c.setCust_id(cust_id);    已经自动递增
        c.setCust_name(&quot;测试名称&quot;);
        c.setCust_mobile(&quot;110&quot;);
        // 保存客户
        session.save(c);
        // 提交事务
        tr.commit();
        // 释放资源
        session.close();
        factory.close();
    }
</code></pre><hr>
<p><strong>回忆：快速入门</strong></p>
<pre><code>1. 下载Hibernate框架的开发包
2. 编写数据库和表结构
3. 创建WEB的项目，导入了开发的jar包
    * MySQL驱动包、Hibernate开发的必须要有的jar包、日志的jar包
4. 编写JavaBean，以后不使用基本数据类型，使用包装类
5. 编写映射的配置文件（核心），先导入开发的约束，里面正常配置标签
6. 编写hibernate的核心的配置文件，里面的内容是固定的
7. 编写代码，使用的类和方法
</code></pre><hr>
<h3 id="技术分析之：Hibernate常用的配置文件"><a href="#技术分析之：Hibernate常用的配置文件" class="headerlink" title="技术分析之：Hibernate常用的配置文件"></a>技术分析之：Hibernate常用的配置文件</h3><hr>
<p><strong>Hibernate配置文件之映射配置文件</strong></p>
<pre><code>1. 映射文件，即Stu.hbm.xml的配置文件
    * &lt;class&gt;标签        -- 用来将类与数据库表建立映射关系
        * name            -- 类的全路径
        * table            -- 表名.(类名与表名一致,那么table属性也可以省略)
        * catalog        -- 数据库的名称，基本上都会省略不写

    * &lt;id&gt;标签            -- 用来将类中的属性与表中的主键建立映射，id标签就是用来配置主键的。
        * name            -- 类中属性名
        * column         -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.)
        * length        -- 字段的程度，如果数据库已经创建好了，那么length可以不写。如果没有创建好，生成表结构时，length最好指定。

    * &lt;property&gt;        -- 用来将类中的普通属性与表中的字段建立映射.
        * name            -- 类中属性名
        * column        -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.)
        * length        -- 数据长度
        * type            -- 数据类型（一般都不需要编写，如果写需要按着规则来编写）
            * Hibernate的数据类型    type=&quot;string&quot;
            * Java的数据类型        type=&quot;java.lang.String&quot;
            * 数据库字段的数据类型    &lt;column name=&quot;name&quot; sql-type=&quot;varchar&quot;/&gt;
</code></pre><hr>
<p><strong>Hibernate配置文件之核心配置文件</strong></p>
<pre><code>1. 核心配置文件的两种方式
    * 第一种方式是属性文件的形式，即properties的配置文件
        * hibernate.properties
            * hibernate.connection.driver_class=com.mysql.jdbc.Driver
        * 缺点
            * 不能加载映射的配置文件，需要手动编写代码去加载

    * 第二种方式是XML文件的形式，开发基本都会选择这种方式
        * hibernate.cfg.xml
            * &lt;property name=&quot;hibernate.connection.driver_class&quot; &gt;com.mysql.jdbc.Driver&lt;/property&gt;
        * 优点
            * 格式比较清晰
            * 编写有提示
            * 可以在该配置文件中加载映射的配置文件（最主要的）

2. 关于hibernate.cfg.xml的配置文件方式
    * 必须有的配置
        * 数据库连接信息:
            hibernate.connection.driver_class              -- 连接数据库驱动程序
            hibernate.connection.url                       -- 连接数据库URL
            hibernate.connection.username                  -- 数据库用户名
            hibernate.connection.password               -- 数据库密码

        * 方言:
            hibernate.dialect                           -- 操作数据库方言

    * 可选的配置
        * hibernate.show_sql                            -- 显示SQL
        * hibernate.format_sql                            -- 格式化SQL
        * hibernate.hbm2ddl.auto                        -- 通过映射转成DDL语句
            * create                -- 每次都会创建一个新的表.---测试的时候
            * create-drop            -- 每次都会创建一个新的表,当执行结束之后,将创建的这个表删除.---测试的时候
            * update                -- 如果有表,使用原来的表.没有表,创建一个新的表.同时更新表结构.
            * validate                -- 如果有表,使用原来的表.同时校验映射文件与表中字段是否一致如果不一致就会报错.

    * 加载映射
        * 如果XML方式：&lt;mapping resource=&quot;cn/itcast/hibernate/domain/User.hbm.xml&quot; /&gt;
</code></pre><hr>
<h3 id="技术分析之Hibernate常用的接口和类"><a href="#技术分析之Hibernate常用的接口和类" class="headerlink" title="技术分析之Hibernate常用的接口和类"></a>技术分析之Hibernate常用的接口和类</h3><hr>
<p><strong>Configuration类和作用</strong></p>
<pre><code>1. Configuration类
    * Configuration对象用于配置并且启动Hibernate。
    * Hibernate应用通过该对象来获得对象-关系映射文件中的元数据，以及动态配置Hibernate的属性，然后创建SessionFactory对象。

    * 简单一句话：加载Hibernate的配置文件，可以获取SessionFactory对象。

2. Configuration类的其他应用（了解）
    * 加载配置文件的种类，Hibernate支持xml和properties类型的配置文件，在开发中基本都使用XML配置文件的方式。
        * 如果采用的是properties的配置文件，那么通过Configuration configuration = new Configuration();就可以假装配置文件
            * 但是需要自己手动加载映射文件
            * 例如：config.addResource(&quot;cn/itcast/domain/Student.hbm.xml&quot;);

        * 如果采用的XML的配置文件，通过Configuration configuration = new Configuration().configure();加载配置文件
</code></pre><hr>
<p><strong>SessionFactory：重要</strong></p>
<pre><code>1. 是工厂类，是生成Session对象的工厂类
2. SessionFactory类的特点
    * 由Configuration通过加载配置文件创建该对象。
    * SessionFactory对象中保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句。同时，SessionFactory还负责维护Hibernate的二级缓存。
        * 预定义SQL语句
            * 使用Configuration类创建了SessionFactory对象是，已经在SessionFacotry对象中缓存了一些SQL语句
            * 常见的SQL语句是增删改查（通过主键来查询）
            * 这样做的目的是效率更高

    * 一个SessionFactory实例对应一个数据库，应用从该对象中获得Session实例。
    * SessionFactory是线程安全的，意味着它的一个实例可以被应用的多个线程共享。
    * SessionFactory是重量级的，意味着不能随意创建或销毁它的实例。如果只访问一个数据库，只需要创建一个SessionFactory实例，且在应用初始化的时候完成。
    * SessionFactory需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为Hibernate的二级缓存，被多线程所共享

3. 总结
    * 一般应用使用一个SessionFactory,最好是应用启动时就完成初始化。
</code></pre><p><img src="./图片/05-SessionFactory.bmp" alt="">    </p>
<hr>
<p><strong>编写HibernateUtil的工具类</strong></p>
<pre><code>1. 具体代码如下
    public class HibernateUtil {
        private static final Configuration cfg;
        private static final SessionFactory factory;
        static{
            // 给常量赋值 
            // 加载配置文件
            cfg = new Configuration().configure();
            // 生成factory对象
            factory = cfg.buildSessionFactory();
        }
        // 获取Session对象
        public static Session openSession(){
            return factory.openSession();
        }
    }
</code></pre><hr>
<p><strong>Session接口</strong></p>
<pre><code>1. 概述
    * Session是在Hibernate中使用最频繁的接口。也被称之为持久化管理器。它提供了和持久化有关的操作，比如添加、修改、删除、加载和查询实体对象
    * Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心
    * Session是线程不安全的
    * 所有持久化对象必须在 session 的管理下才可以进行持久化操作
    * Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久化操作的数据都缓存在 session 对象处
    * 持久化类与 Session 关联起来后就具有了持久化的能力

2. 特点
    * 不是线程安全的。应避免多个线程使用同一个Session实例
    * Session是轻量级的，它的创建和销毁不会消耗太多的资源。应为每次客户请求分配独立的Session实例
    * Session有一个缓存，被称之为Hibernate的一级缓存。每个Session实例都有自己的缓存

3. 常用的方法
    * save(obj)
    * delete(obj)  
    * get(Class,id)
    * update(obj)
    * saveOrUpdate(obj)                    -- 保存或者修改（如果没有数据，保存数据。如果有，修改数据）
    * createQuery()                     -- HQL语句的查询的方式
</code></pre><hr>
<p><strong>Transaction接口</strong></p>
<pre><code>1. Transaction是事务的接口
2. 常用的方法
    * commit()                -- 提交事务
    * rollback()            -- 回滚事务

3. 特点
    * Hibernate框架默认情况下事务不自动提交.需要手动提交事务
    * 如果没有开启事务，那么每个Session的操作，都相当于一个独立的事务
</code></pre><hr>
<p><strong>开发步骤</strong></p>
<pre><code>1. 准备环境
    * 在资料/crm/ui/WebRoot下所有的文件，拷贝到工程中
    * 引入JSTL的标签库，JSP页面会报错
</code></pre><hr>
<p><strong>编写代码</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;今天任务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 使用Hibernate框架完成对客户的增删改查的操作
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;教学导航&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 能够说出
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式数据库系统</title>
    <link href="http://www.orangezhang.com/2017/06/23/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.orangezhang.com/2017/06/23/分布式数据库系统/</id>
    <published>2017-06-23T04:41:52.797Z</published>
    <updated>2017-06-23T04:41:52.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-环境介绍"><a href="#一-环境介绍" class="headerlink" title="一.环境介绍"></a>一.环境介绍</h2><h3 id="1-1-mysql节点1环境"><a href="#1-1-mysql节点1环境" class="headerlink" title="1.1. mysql节点1环境"></a>1.1. mysql节点1环境</h3><ul>
<li>操作系统版本  : centos6.5 x64</li>
<li>数据库版本    : mysql-5.7.4</li>
<li>mycat版本    ：1.3 release</li>
<li>数据库名      : db1</li>
<li>hostname:c1</li>
<li>ip:192.168.58.11</li>
</ul>
<h3 id="1-2-mysql节点2环境"><a href="#1-2-mysql节点2环境" class="headerlink" title="1.2. mysql节点2环境"></a>1.2. mysql节点2环境</h3><ul>
<li>操作系统版本  : centos6.5 x64</li>
<li>数据库版本    : mysql-5.7.4</li>
<li>mycat版本    ：1.3 release</li>
<li>数据库名     : db2</li>
<li>hostname:c2</li>
<li>ip:192.168.58.12</li>
</ul>
<h3 id="1-3-mycat环境"><a href="#1-3-mycat环境" class="headerlink" title="1.3.mycat环境"></a>1.3.mycat环境</h3><pre><code>安装在c1
</code></pre><h3 id="1-4-前提条件"><a href="#1-4-前提条件" class="headerlink" title="1.4. 前提条件"></a>1.4. 前提条件</h3><p>   两个节点都安装好mysql5.7.4</p>
<h2 id="二-安装mycat"><a href="#二-安装mycat" class="headerlink" title="二.安装mycat"></a>二.安装mycat</h2><h3 id="2-1-创建用户及组"><a href="#2-1-创建用户及组" class="headerlink" title="2.1.创建用户及组"></a>2.1.创建用户及组</h3><p>root &gt;</p>
<p>创建一个新的group<br> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">groupadd dba</span></div></pre></td></tr></table></figure></p>
<p>创建一个新的用户，并加入group<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">useradd -g dba mycat</span></div></pre></td></tr></table></figure></p>
<p>给新用户设置密码，<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">passwd mycat</span></div></pre></td></tr></table></figure></p>
<h3 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2.解压"></a>2.2.解压</h3><p>mycat &gt;<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar -xzvf Mycat-server<span class="number">-1.3</span><span class="number">.0</span><span class="number">.3</span>-release<span class="number">-20150527095523</span>-linux.tar.gz</div><div class="line">mkdri /home/mycat/app</div><div class="line">mv mycat /home/mycat/app/mycat</div></pre></td></tr></table></figure></p>
<h3 id="2-3-设置环境变量"><a href="#2-3-设置环境变量" class="headerlink" title="2.3.设置环境变量"></a>2.3.设置环境变量</h3><p> vim /home/mycat/.bash_profile<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="builtin-name">export</span> <span class="attribute">MYCAT_HOME</span>=/home/mycat/app/mycat</div><div class="line"><span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$MYCAT_HOME/bin</div></pre></td></tr></table></figure></p>
<p>令修改生效<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[mycat<span class="variable">@c1</span> ~]<span class="variable">$ </span>source .bash_profile</div></pre></td></tr></table></figure></p>
<p><strong>测试是否配置成功</strong><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mycat@c1 ~]$ echo <span class="variable">$MYCAT_HOME</span></div><div class="line"><span class="regexp">/home/my</span>cat<span class="regexp">/app/my</span>cat</div></pre></td></tr></table></figure></p>
<h3 id="2-4-修改wrapper-conf文件"><a href="#2-4-修改wrapper-conf文件" class="headerlink" title="2.4.修改wrapper.conf文件"></a>2.4.修改wrapper.conf文件</h3><p>cd /usr/local/mycat/conf<br>vim wrapper.conf<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Java Application</span></div><div class="line">wrapper.java.command=wrapper.java.command=<span class="regexp">/usr/</span>local<span class="regexp">/java/</span>jdk1.<span class="number">7.0</span>_67<span class="regexp">/bin/</span>java</div></pre></td></tr></table></figure></p>
<h3 id="2-5-启动mycat"><a href="#2-5-启动mycat" class="headerlink" title="2.5.启动mycat"></a>2.5.启动mycat</h3><p><strong>启动:</strong><br>mycat start<br>mycat 就已经启动了 端口8066<br><strong>关闭mycat:</strong><br>mycat stop</p>
<h2 id="三、配置mycat"><a href="#三、配置mycat" class="headerlink" title="三、配置mycat"></a>三、配置mycat</h2><h3 id="3-1-my-cnf追加一行"><a href="#3-1-my-cnf追加一行" class="headerlink" title="3.1 my.cnf追加一行"></a>3.1 my.cnf追加一行</h3><p>vim /etc/my.cnf<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">lower_case_table_names</span> = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>如果找不到my.cnf文件，copy一个：<br>cp /usr/share/mysql/my-default.cnf /etc/my.cnf</p>
<h3 id="3-2配置schema"><a href="#3-2配置schema" class="headerlink" title="3.2配置schema"></a>3.2配置schema</h3><p>vim $MYCAT_HOME/conf/schema.xml<br>每个属性的含义请参考权威指南,这里给出基本的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="meta">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://org.opencloudb/"</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"JamesMycatSchema"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 需要分片的表，在节点dn1,dn2上分片，分片规则是auto-sharding-long --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"travelrecord"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">rule</span>=<span class="string">"auto-sharding-long"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"company"</span> <span class="attr">primaryKey</span>=<span class="string">"ID"</span> <span class="attr">type</span>=<span class="string">"global"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"goods"</span> <span class="attr">primaryKey</span>=<span class="string">"ID"</span> <span class="attr">type</span>=<span class="string">"global"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"hotnews"</span> <span class="attr">primaryKey</span>=<span class="string">"ID"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span></span></div><div class="line">			<span class="attr">rule</span>=<span class="string">"mod-long"</span> /&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"employee"</span> <span class="attr">primaryKey</span>=<span class="string">"ID"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span></span></div><div class="line">			<span class="attr">rule</span>=<span class="string">"sharding-by-intfile"</span> /&gt;</div><div class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!--数据节点dn1，对应的主机c1,对应是数据库db1 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"c1"</span> <span class="attr">database</span>=<span class="string">"db1"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn2"</span> <span class="attr">dataHost</span>=<span class="string">"c2"</span> <span class="attr">database</span>=<span class="string">"db2"</span> /&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 主机C1--&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"c1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span></span></div><div class="line">		<span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span>&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!--mysql数据库的连接串 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"c1:3306"</span> <span class="attr">user</span>=<span class="string">"mycat"</span></span></div><div class="line">			<span class="attr">password</span>=<span class="string">"mycat"</span>&gt;</div><div class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 主机C2--&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"c2"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span></span></div><div class="line">		<span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span>&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></div><div class="line"></div><div class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM2"</span> <span class="attr">url</span>=<span class="string">"c2:3306"</span> <span class="attr">user</span>=<span class="string">"mycat"</span></span></div><div class="line">			<span class="attr">password</span>=<span class="string">"mycat"</span>&gt;</div><div class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></div></pre></td></tr></table></figure>
<p>3.3 配置server.xml<br>追加：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 为mycat配置一个用户 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"cat"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>cat<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>JamesMycatSchema<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">user</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="四-测试"><a href="#四-测试" class="headerlink" title="四.测试"></a>四.测试</h2><p>这里使用mycat自带的表来测试<br>启动mycat:<br>mycat start<br>使用Navicat for MySQL连接mycat:<br>cat/cat@192.168.58.11</p>
<p>建表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee (<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">100</span>),sharding_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>);</div></pre></td></tr></table></figure></p>
<p>插入数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee(<span class="keyword">id</span>,<span class="keyword">name</span>,sharding_id) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'leader us'</span>,<span class="number">10000</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee(<span class="keyword">id</span>,<span class="keyword">name</span>,sharding_id) <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'me'</span>,<span class="number">10010</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee(<span class="keyword">id</span>,<span class="keyword">name</span>,sharding_id) <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'mycat'</span>,<span class="number">10000</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee(<span class="keyword">id</span>,<span class="keyword">name</span>,sharding_id) <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">'mydog'</span>,<span class="number">10010</span>);</div></pre></td></tr></table></figure></p>
<p>分别到数据DB1,DB2查看，可以看到在DB1中有：<br>1    leader us    10000<br>3    mycat    10000<br>DB2中有：<br>2    me    10010<br>4    mydog    10010</p>
<p>这说明分片成功了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-环境介绍&quot;&gt;&lt;a href=&quot;#一-环境介绍&quot; class=&quot;headerlink&quot; title=&quot;一.环境介绍&quot;&gt;&lt;/a&gt;一.环境介绍&lt;/h2&gt;&lt;h3 id=&quot;1-1-mysql节点1环境&quot;&gt;&lt;a href=&quot;#1-1-mysql节点1环境&quot; class=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL性能优化的最佳20+条经验</title>
    <link href="http://www.orangezhang.com/2017/06/23/%E9%9B%86%E5%90%88%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.orangezhang.com/2017/06/23/集合概念详解/</id>
    <published>2017-06-23T04:28:00.175Z</published>
    <updated>2017-06-23T06:17:12.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我-们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时-尤其是查表时的SQL语句-，我们都需要注意数据操作的性能。这里，我们不会讲过-多的SQL语句的优化，而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。"><a href="#今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我-们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时-尤其是查表时的SQL语句-，我们都需要注意数据操作的性能。这里，我们不会讲过-多的SQL语句的优化，而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。" class="headerlink" title="今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我 们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时(尤其是查表时的SQL语句)，我们都需要注意数据操作的性能。这里，我们不会讲过 多的SQL语句的优化，而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。"></a>今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我 们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时(尤其是查表时的SQL语句)，我们都需要注意数据操作的性能。这里，我们不会讲过 多的SQL语句的优化，而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。</h1><p><strong> 为查询缓存优化你的查询</strong><br>顺序容器，底层通过数组实现<br>每个ArrayList都有一个容量（capacity,底层数组的实际大小）,添加元素时容量不足，容器会自动增加底层数组的大小（原来的1.5倍）<br>size(), isEmpty(), get(), set()方法均能在常数时间内完成（O(1)复杂度）<br>add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比，其余方法大都是线性时间<br>没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代<br><strong>LinkedList</strong><br>同时实现了List接口和 Deque接口，既可以看作顺序容器，也可以用作队列或者栈，底层实现是一个双向链表<br>成员变量first和last分别指向链表的头和尾<br>所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间<br>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装<br><strong>ArrayDeque</strong><br>实现了Deque接口，Deque的含义是“double ended queue”，即双端队列，既可以当作栈使用，也可以当作队列使用<br>当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的<strong>ArrayDeque</strong><br>底层通过循环数组实现，也就是说数组的任何一点都可能被看作起点或者终点，跟ArrayList一样，当容量不够的时候会自动增加数组的大小<br>成员变量head和tail分别指向第一个元素在数组中的位置和最后一个元素在数组中的位置的下一个位置，head不一定为0，tail也不一定比head大<br>非线程安全（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。<br><strong>TreeMap</strong><br>实现了SortedMap接口，会按照key的大小顺序对Map中的元素进行排序<br>底层通过红黑树实现，因此containsKey(), get(), put(), remove()都有着log(n)的时间复杂度<br>非同步（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成（wrapped）同步的：SortedMap m = Collections.synchronizedSortedMap(new TreeMap(…));<br><strong>TreeSet</strong><br>是对TeeMap的简单包装（TreeSet里面有一个TreeMap，适配器模式），对TreeSet的函数调用都会转换成合适的TeeMap方法<br>红黑树<br>一种近似平衡的二叉查找树，能够确保任何一个节点的左右子树的高度不会超过二者中较低那个的一倍<br>要满足以下条件：<br>1.每个节点要么是红色，要么是黑色<br>2.根节点必须是黑色<br>3.红色节点不能连续（也就是红色节点的孩子和父亲都不能是红色）<br>4.对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。<br>在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件。<br>插入节点时，一般插入红色节点，即可能会破坏条件2和3。<br>调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：左旋（RotateLeft），右旋（RotateRight）。<br><strong>HashMap</strong><br>实现了Map接口，允许放入null元素<br>哈希表采用冲突链表方式<br>不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同<br>hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”<br>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。<br>初始容量（inital capacity）和负载系数（load factor）影响HashMap的性能，初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity<em>load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。<br>hashmap的容量（table.length）必须是2的指数，这时hash(k)&amp;(table.length-1)等价于hash(k)%table.length，因为table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了<br>除未实现同步外，该类其余跟Hashtable大致相同<br><strong>HashSet</strong><br>是对HashMap的简单包装（HashSet里面有一个HashMap,适配器模式），对HashSet的函数调用都会转换成合适的HashMap方法<br><strong>LinkedHashMap</strong><br>是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linked list）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。<br>LinkedHashMap维护双向链表时，实际维护的是一个循环双向链表，不像LinkedList那样，用两个指针first和last分别指向链表的头和尾，而是只用一个header指针指向双向链表的头，链表头的before指针指向链表的尾<br><strong>LinkedHashSet</strong><br>是对LinkedHashMap的简单包装（LinkedHashSet里面有一个LinkedHashMap,适配器模式），对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法<br>PriorityQueue<br>优先队列，实现了Queue接口，不允许放入null元素<br>能保证每次取出的元素都是队列中权值最小的，元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator）<br>底层是通过数组实现的最小值堆（完全二叉树）<br>取出堆顶数据但不删除时间复杂度O(1),其他插入、删除等操作时间复杂度O(logN)<br><em>*WeakHashMap</em></em><br>存放的是对象的弱引用，因此WeakHashMap里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。<br>适用于需要缓存的场景：对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误<br>将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。<br>没有WeekHashSet，不过Java Collections工具类给出了解决方案，Collections.newSetFromMap(Map map)方法可以将任何 Map包装成一个Set：</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我-们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时-尤其是查表时的SQL语句-，我们都需要注意数据操作的性能
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.orangezhang.com/2017/06/23/hello-world/"/>
    <id>http://www.orangezhang.com/2017/06/23/hello-world/</id>
    <published>2017-06-22T16:23:57.399Z</published>
    <updated>2017-06-22T16:23:57.399Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
